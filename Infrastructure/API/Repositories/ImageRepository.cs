using System.Net;
using CloudinaryDotNet;
using CloudinaryDotNet.Actions;
using RealEstate.Application.Contracts;

namespace RealEstate.Infrastructure.API.Repositories
{
    /// <summary>
    /// Repository responsible for direct interaction with Cloudinary
    /// to upload images and return their secure URLs.
    /// </summary>
    public class ImageRepository : IImageRepository
    {
        private readonly Cloudinary _cloudinary;

        /// <summary>
        /// Initializes a new instance of the <see cref="ImageRepository"/> class with the injected Cloudinary client.
        /// </summary>
        /// <param name="cloudinary">Configured Cloudinary instance (injected).</param>
        public ImageRepository(Cloudinary cloudinary)
        {
            _cloudinary = cloudinary;
        }

        /// <summary>
        /// Uploads a single image to Cloudinary and returns its secure URL.
        /// </summary>
        /// <param name="file">File to upload.</param>
        /// <param name="folderName">Folder name in Cloudinary.</param>
        /// <param name="fileName">Optional file name.</param>
        /// <returns>Secure URL of the uploaded image.</returns>
        public async Task<string> UploadImageAsync(
            IFormFile file,
            string folderName,
            string? fileName = null)
        {
            using var stream = file.OpenReadStream();

            // Generate an autogenerated name if fileName is not provided
            var publicFileName = string.IsNullOrWhiteSpace(fileName)
                ? Guid.NewGuid().ToString("N") // random name
                : fileName;

            // Cloudinary builds the final path with Folder + PublicId
            var uploadParams = new ImageUploadParams
            {
                File = new FileDescription(file.FileName, stream),
                PublicId = publicFileName, // <-- only the name + extension
                Folder = $"real-estate-app/images/{folderName}", // <-- do not include the name here
                Transformation = new Transformation().Quality("auto"), // <-- without FetchFormat("auto")
            };

            var uploadResult = await _cloudinary.UploadAsync(uploadParams);

            if (uploadResult.StatusCode != HttpStatusCode.OK)
            {
                throw new InvalidOperationException($"Image upload failed: {uploadResult.Error?.Message}");
            }

            return uploadResult.SecureUrl.ToString();
        }

        /// <summary>
        /// Uploads multiple images to Cloudinary and returns their secure URLs.
        /// </summary>
        /// <param name="files">List of files to upload.</param>
        /// <param name="folderName">Folder name in Cloudinary.</param>
        /// <returns>List of secure URLs of the uploaded images.</returns>
        public async Task<List<string>> UploadImagesAsync(List<IFormFile> files, string folderName)
        {
            var uploadTasks = files.Select(file =>
            {
                // Use the original file name without extension
                var originalName = Path.GetFileNameWithoutExtension(file.FileName);
                return UploadImageAsync(file, folderName, originalName);
            });

            var urls = await Task.WhenAll(uploadTasks);
            return urls.ToList();
        }

        /// <summary>
        /// Deletes an image from Cloudinary by its public identifier.
        /// </summary>
        /// <param name="publicId">The public identifier of the image to delete.</param>
        /// <returns>True if deletion was successful, False otherwise.</returns>
        public async Task<bool> DeleteImageAsync(string publicId)
        {
            var deleteParams = new DeletionParams(publicId);

            var deletionResult = await _cloudinary.DestroyAsync(deleteParams);

            return deletionResult.Result.ToLower() == "ok" || deletionResult.Result.ToLower() == "not found";
        }
    }
}
